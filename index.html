<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Hype Oracle</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { font-family: -apple-system, system-ui, sans-serif; background: #f0f2f5; padding: 15px; margin: 0; display: flex; flex-direction: column; align-items: center; }
    #app { width: 100%; max-width: 420px; }

    .filters {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding: 6px 2px 12px 2px;
      margin-bottom: 6px;
      scrollbar-width: none;
    }
    .filters::-webkit-scrollbar { display: none; }
    .chip {
      flex: 0 0 auto;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #fff;
      color: #111827;
      font-weight: 800;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }
    .chip.active {
      background: #111827;
      color: #fff;
      border-color: #111827;
    }

    .top-note{
      display:none;
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius: 16px;
      padding: 10px 12px;
      margin: 0 0 12px 0;
      color:#374151;
      font-size: 13px;
      font-weight: 650;
      line-height: 1.35;
    }

    .card { background: #fff; border-radius: 24px; padding: 22px; box-shadow: 0 10px 25px rgba(0,0,0,0.06); margin-bottom: 16px; }
    h2 { font-size: 18px; color: #222; margin: 0 0 10px 0; line-height: 1.35; text-align: center; }

    .event-img {
      width: 100%;
      height: 160px;
      border-radius: 18px;
      margin: 8px 0 14px 0;
      display: block;
      object-fit: cover;
      background: #f3f4f6;
    }

    .poll-container { height: 12px; background: #eee; border-radius: 6px; display: flex; overflow: hidden; margin-bottom: 10px; }
    .poll-yes { background: #34c759; transition: width 0.6s; }
    .poll-no { background: #ff3b30; transition: width 0.6s; }
    .stats-text { display: flex; justify-content: space-between; font-weight: 700; font-size: 12px; margin-bottom: 14px; color: #666; gap: 10px; }
    input { width: 100%; height: 56px; border: 2px solid #e0e0e0; border-radius: 16px; font-size: 22px; font-weight: 900; text-align: center; outline: none; color: #222; }
    input:focus { border-color: #0088cc; }
    .hint { font-size: 12px; color: #888; margin-top: -4px; margin-bottom: 12px; text-align: center; }
    .win-estimate { font-size: 13px; color: #0088cc; font-weight: 650; margin-bottom: 12px; min-height: 32px; line-height: 1.55; text-align: center; }
    .win-estimate b { color: #222; }
    .profit { color: #34c759; font-size: 11px; }
    .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 10px; }
    button { padding: 16px; border-radius: 16px; border: none; color: #fff; font-size: 16px; font-weight: 850; cursor: pointer; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .btn-yes { background: #34c759; box-shadow: 0 4px 0 #28a745; }
    .btn-no { background: #ff3b30; box-shadow: 0 4px 0 #d93025; }
    .meta { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: 10px; color: #777; font-size: 12px; }
    .badge { background:#f3f4f6; border:1px solid #e5e7eb; padding:6px 10px; border-radius: 999px; }
    .loading { color: #888; margin-top: 50px; text-align: center; }
    .error { color: #b42318; background:#fff; border-radius: 18px; padding: 14px; box-shadow: 0 10px 25px rgba(0,0,0,0.06); }
    .success { color: #067647; }
  </style>
</head>

<body>
  <div id="app"><div class="loading">Загрузка...</div></div>

  <script>
    const tg = window.Telegram?.WebApp;
    if (tg) tg.ready();

    const CONTRACT = "EQDY-ZA54ipvqiA8WeB64yI1h_2OB4M3AQxn924V0U6VwfNG";
    const REFRESH_MS = 15000;
    const MIN_BET = 0.10;

    const CATEGORY_LABELS = {
      sport: "Спорт",
      politics: "Политика",
      finance: "Финансы",
      showbiz: "Шоу-Бизнес",
    };

    // Попап об обновлении (не чаще 1 раза в час)
    const ENTRY_POPUP_KEY = "ho_last_update_hint_at";
    const ENTRY_POPUP_EVERY_MS = 60 * 60 * 1000;

    let eventList = [];
    let activeCategory = "all";
    let refreshTimer = null;
    const state = new Map();

    // Надежное декодирование Base64 с поддержкой кириллицы и эмодзи
    function safeBase64ToJson(b64) {
      try {
        const jsonString = decodeURIComponent(escape(window.atob((b64 || "").replace(/-/g, "+").replace(/_/g, "/"))));
        return JSON.parse(jsonString);
      } catch (e) {
        throw new Error("Ошибка декодирования данных");
      }
    }

    function clamp(n, a, b) { return Math.min(Math.max(n, a), b); }

    function parseAmount(inputValue) {
      const n = Number.parseFloat(String(inputValue ?? "").replace(",", "."));
      if (!Number.isFinite(n)) return null;
      return Math.round(n * 100) / 100;
    }

    function fmtTon(n) {
      if (!Number.isFinite(n)) return "--";
      return n.toFixed(2);
    }

    // Утилита для задержки вычислений (Debounce)
    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    function setAppError(msg) {
      const app = document.getElementById("app");
      app.innerHTML = "";
      const div = document.createElement("div");
      div.className = "error";
      div.textContent = msg;
      app.appendChild(div);
    }

    function showTopNote(text) {
      const note = document.getElementById("top-note");
      if (!note) return;
      note.textContent = text;
      note.style.display = "block";
    }

    function maybeShowUpdateHintOncePerHour() {
      const now = Date.now();
      let last = 0;

      try {
        last = Number(localStorage.getItem(ENTRY_POPUP_KEY) || "0");
        if (!Number.isFinite(last)) last = 0;
      } catch {
        last = 0;
      }

      if (now - last < ENTRY_POPUP_EVERY_MS) return;

      const msg =
        "Возможны новые события.\n" +
        "Нажми “Обновить сейчас” — я пришлю новую кнопку в чат.";

      const doRefresh = () => {
        if (!tg) {
          showTopNote("Открой приложение через Telegram.");
          return;
        }
        try {
          tg.sendData(JSON.stringify({ type: "refresh" }));
          setTimeout(() => tg.close(), 150);
        } catch {
          showTopNote("Не удалось отправить запрос боту. Напиши /events в чате.");
        }
      };

      if (tg?.showPopup) {
        tg.showPopup({
          title: "Обновление событий",
          message: msg.slice(0, 256),
          buttons: [
            { id: "refresh_now", type: "default", text: "Обновить сейчас" },
            { type: "close", text: "Позже" }
          ]
        }, (btnId) => {
          if (btnId === "refresh_now") doRefresh();
        });
      } else if (tg?.showConfirm) {
        tg.showConfirm(msg, (ok) => { if (ok) doRefresh(); });
      } else if (tg?.showAlert) {
        tg.showAlert(msg);
      } else {
        showTopNote(msg);
      }

      try { localStorage.setItem(ENTRY_POPUP_KEY, String(now)); } catch {}
    }

    function hexToBigInt(x) {
      if (typeof x !== "string") return null;
      if (x.startsWith("0x") || x.startsWith("0X")) return BigInt(x);
      if (/^\d+$/.test(x)) return BigInt(x);
      return null;
    }

    function asBigIntFromElement(el) {
      const a = el?.number?.number ?? el?.number;
      if (a !== undefined) { try { return BigInt(String(a)); } catch {} }
      const b = el?.value ?? el?.num ?? el?.valueHex;
      const bi = hexToBigInt(String(b ?? ""));
      if (bi !== null) return bi;
      return null;
    }

    function asBoolFromElement(el) {
      const bi = asBigIntFromElement(el);
      if (bi === null) return null;
      return bi !== 0n;
    }

    function extractTupleElements(stackItem) {
      if (Array.isArray(stackItem) && stackItem.length >= 2) {
        const maybe = stackItem[1];
        const elements = maybe?.elements;
        if (Array.isArray(elements)) return elements;
      }
      if (stackItem && typeof stackItem === "object") {
        const t = stackItem.type ?? stackItem["@type"];
        if (t && String(t).toLowerCase().includes("tuple")) {
          const v = stackItem.value ?? stackItem.elements ?? stackItem.tuple;
          if (Array.isArray(v)) return v;
          if (v?.elements && Array.isArray(v.elements)) return v.elements;
        }
      }
      return null;
    }

    function extractEventDataFromStack(stack) {
      if (!Array.isArray(stack)) return null;

      let elements = extractTupleElements(stack[0]);

      if (!elements) {
        if (stack.length >= 4 && (stack[0]?.number || stack[0]?.type === "num")) {
          elements = stack;
        } else {
          for (const it of stack) {
            const el = extractTupleElements(it);
            if (el) { elements = el; break; }
          }
        }
      }

      if (!elements || elements.length < 4) return null;

      const yesNano = asBigIntFromElement(elements[0]);
      const noNano = asBigIntFromElement(elements[1]);
      const isResolved = asBoolFromElement(elements[2]);
      const winningOutcome = asBoolFromElement(elements[3]);

      if (yesNano === null || noNano === null || isResolved === null || winningOutcome === null) return null;
      return { yesNano, noNano, isResolved, winningOutcome };
    }

    function isNullOptionalEvent(stack) {
      return (
        Array.isArray(stack) &&
        Array.isArray(stack[0]) &&
        stack[0][0] === "list" &&
        Array.isArray(stack[0][1]?.elements) &&
        stack[0][1].elements.length === 0
      );
    }

    // НОВАЯ ФУНКЦИЯ: Batch запрос всех событий одним вызовом
    async function fetchAllEventsFromToncenter(eventIds) {
      if (!eventIds || eventIds.length === 0) return [];

      const params = new URLSearchParams(window.location.search);
      const API_KEY = params.get("api");
      if (!API_KEY) throw new Error("Нет ключа toncenter: отсутствует ?api=...");

      const url = `https://toncenter.com/api/v2/jsonRPC?api_key=${encodeURIComponent(API_KEY)}`;

      const rpcPayload = eventIds.map((id, index) => ({
        id: index + 1,
        jsonrpc: "2.0",
        method: "runGetMethod",
        params: {
          address: CONTRACT,
          method: "get_event",
          stack: [["num", String(id)]],
        }
      }));

      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(rpcPayload),
      });

      const jsonResponses = await res.json();

      if (!Array.isArray(jsonResponses)) {
        if (jsonResponses.error) throw new Error(jsonResponses.error.message || "Toncenter error");
        throw new Error("Неожиданный ответ от Toncenter");
      }

      const results = [];

      for (let i = 0; i < eventIds.length; i++) {
        const eventId = eventIds[i];
        const rpcRes = jsonResponses.find(r => r.id === i + 1);

        if (!rpcRes || rpcRes.error) {
           results.push({ eventId, error: rpcRes?.error?.message || "RPC Error" });
           continue;
        }

        const stack = rpcRes.result?.stack;

        if (isNullOptionalEvent(stack)) {
          results.push({ eventId, yes: 0, no: 0, total: 0, isResolved: false, winningOutcome: false, error: null });
          continue;
        }

        const parsed = extractEventDataFromStack(stack);
        if (!parsed) {
          results.push({ eventId, error: "Неожиданный формат stack" });
          continue;
        }

        const yes = Number(parsed.yesNano) / 1e9;
        const no = Number(parsed.noNano) / 1e9;

        results.push({
          eventId,
          yes,
          no,
          total: yes + no,
          isResolved: parsed.isResolved,
          winningOutcome: parsed.winningOutcome,
          error: null
        });
      }

      return results;
    }

    // НОВАЯ ФУНКЦИЯ: Обработка результатов Batch-запроса
    async function syncAllEvents(eventIds) {
      if (!eventIds.length) return;
      try {
        const dataList = await fetchAllEventsFromToncenter(eventIds);

        for (const data of dataList) {
          const prev = state.get(data.eventId) || {};

          if (data.error) {
            state.set(data.eventId, { ...prev, lastSyncAt: Date.now(), error: data.error });
            const meta = document.getElementById(`meta-${data.eventId}`);
            if (meta) meta.textContent = `Ошибка: ${data.error.slice(0, 40)}`;
          } else {
            state.set(data.eventId, { ...data, lastSyncAt: Date.now(), error: null });
            renderFromState(data.eventId);
          }
        }
      } catch (e) {
        console.error("Batch sync failed:", e);
        for (const id of eventIds) {
          const prev = state.get(id) || {};
          state.set(id, { ...prev, lastSyncAt: Date.now(), error: String(e.message) });
          const meta = document.getElementById(`meta-${id}`);
          if (meta) meta.textContent = `Ошибка сети`;
        }
      }
    }

    function buildFilters(container) {
      const bar = document.createElement("div");
      bar.className = "filters";

      const chips = [
        { key: "all", label: "Все" },
        ...Object.keys(CATEGORY_LABELS).map(k => ({ key: k, label: CATEGORY_LABELS[k] }))
      ];

      chips.forEach(ch => {
        const el = document.createElement("div");
        el.className = "chip" + (ch.key === activeCategory ? " active" : "");
        el.textContent = ch.label;
        el.onclick = () => {
          activeCategory = ch.key;
          container.innerHTML = "";
          renderApp(container);
        };
        bar.appendChild(el);
      });

      return bar;
    }

    function buildCard(event) {
      const card = document.createElement("div");
      card.className = "card";
      card.dataset.eventId = String(event.id);

      const h2 = document.createElement("h2");
      h2.textContent = event.title || `Событие #${event.id}`;
      card.appendChild(h2);

      if (event.image_url && /^https:\/\//i.test(String(event.image_url))) {
        const img = document.createElement("img");
        img.className = "event-img";
        img.src = String(event.image_url);
        img.alt = "";
        img.loading = "lazy";
        img.referrerPolicy = "no-referrer";
        card.appendChild(img);
      }

      const poll = document.createElement("div");
      poll.className = "poll-container";
      const barYes = document.createElement("div");
      barYes.className = "poll-yes";
      barYes.id = `bar-y-${event.id}`;
      barYes.style.width = "50%";
      const barNo = document.createElement("div");
      barNo.className = "poll-no";
      barNo.id = `bar-n-${event.id}`;
      barNo.style.width = "50%";
      poll.appendChild(barYes);
      poll.appendChild(barNo);
      card.appendChild(poll);

      const stats = document.createElement("div");
      stats.className = "stats-text";
      const txtY = document.createElement("span");
      txtY.id = `txt-y-${event.id}`;
      txtY.textContent = "ДА: --";
      const txtN = document.createElement("span");
      txtN.id = `txt-n-${event.id}`;
      txtN.textContent = "НЕТ: --";
      stats.appendChild(txtY);
      stats.appendChild(txtN);
      card.appendChild(stats);

      const input = document.createElement("input");
      input.type = "number";
      input.inputMode = "decimal";
      input.min = String(MIN_BET);
      input.step = "0.01";
      input.placeholder = "Сумма TON";
      input.id = `am-${event.id}`;
      
      // ИСПОЛЬЗУЕМ DEBOUNCE: расчет происходит через 300мс после ввода
      const debouncedRender = debounce(() => renderEstimate(event.id), 300);
      input.addEventListener("input", debouncedRender);
      
      card.appendChild(input);

      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = `Минимум ${MIN_BET.toFixed(2)} TON.`;
      card.appendChild(hint);

      const est = document.createElement("div");
      est.className = "win-estimate";
      est.id = `est-${event.id}`;
      est.textContent = "Укажите сумму для прогноза";
      card.appendChild(est);

      const btnGrid = document.createElement("div");
      btnGrid.className = "btn-grid";

      const btnYes = document.createElement("button");
      btnYes.className = "btn-yes";
      btnYes.textContent = "ДА";
      btnYes.addEventListener("click", () => doBet(event.id, true));

      const btnNo = document.createElement("button");
      btnNo.className = "btn-no";
      btnNo.textContent = "НЕТ";
      btnNo.addEventListener("click", () => doBet(event.id, false));

      btnGrid.appendChild(btnYes);
      btnGrid.appendChild(btnNo);
      card.appendChild(btnGrid);

      const meta = document.createElement("div");
      meta.className = "meta";
      const badge = document.createElement("div");
      badge.className = "badge";
      badge.id = `meta-${event.id}`;
      badge.textContent = "Обновление: --";
      const status = document.createElement("div");
      status.id = `status-${event.id}`;
      status.textContent = "";
      meta.appendChild(badge);
      meta.appendChild(status);
      card.appendChild(meta);

      return card;
    }

    function setCardResolved(eventId, winningOutcome) {
      const card = document.querySelector(`.card[data-event-id="${eventId}"]`);
      if (!card) return;

      const status = document.getElementById(`status-${eventId}`);
      if (status) {
        status.textContent = `Завершено: ${winningOutcome ? "ДА" : "НЕТ"}`;
        status.className = "success";
      }

      card.querySelectorAll("button").forEach(b => b.disabled = true);

      const est = document.getElementById(`est-${eventId}`);
      if (est) est.innerHTML = `Событие завершено. Ожидай сообщение от бота с кнопкой выигрыша.`;
    }

    function renderFromState(eventId) {
      const info = state.get(eventId);
      if (!info) return;

      const y = info.yes;
      const n = info.no;
      const total = info.total;

      const yP = total > 0 ? Math.round((y / total) * 100) : 50;

      const barY = document.getElementById(`bar-y-${eventId}`);
      const barN = document.getElementById(`bar-n-${eventId}`);
      if (barY) barY.style.width = `${clamp(yP, 0, 100)}%`;
      if (barN) barN.style.width = `${clamp(100 - yP, 0, 100)}%`;

      const txtY = document.getElementById(`txt-y-${eventId}`);
      const txtN = document.getElementById(`txt-n-${eventId}`);
      if (txtY) txtY.textContent = `ДА: ${yP}% (${fmtTon(y)} T)`;
      if (txtN) txtN.textContent = `НЕТ: ${100 - yP}% (${fmtTon(n)} T)`;

      const meta = document.getElementById(`meta-${eventId}`);
      if (meta) meta.textContent = `Обновление: ${new Date(info.lastSyncAt).toLocaleTimeString()}`;

      if (info.isResolved) setCardResolved(eventId, info.winningOutcome);
      renderEstimate(eventId);
    }

    function renderEstimate(eventId) {
      const est = document.getElementById(`est-${eventId}`);
      const input = document.getElementById(`am-${eventId}`);
      const info = state.get(eventId);

      if (!est) return;
      if (!info) { est.textContent = "Нет данных с блокчейна"; return; }
      if (info.isResolved) return;

      const amount = parseAmount(input?.value);
      if (amount === null) { est.textContent = "Укажите сумму для прогноза"; return; }
      if (amount < MIN_BET) { est.textContent = `Минимальная ставка ${MIN_BET.toFixed(2)} TON`; return; }

      const yesPool = info.yes;
      const noPool = info.no;

      if ((yesPool + noPool) <= 0) {
        est.textContent = "Пока нет ставок — стань первым.";
        return;
      }

      const fee = 0.9;
      const denomYes = (yesPool + amount);
      const denomNo = (noPool + amount);
      if (denomYes <= 0 || denomNo <= 0) { est.textContent = "Недостаточно данных для расчёта"; return; }

      const winIfYes = amount + (amount / denomYes) * (noPool * fee);
      const winIfNo  = amount + (amount / denomNo)  * (yesPool * fee);

      est.innerHTML =
        `Победа <b>ДА</b>: ~${winIfYes.toFixed(2)} T <span class="profit">(+${(winIfYes - amount).toFixed(2)})</span><br>` +
        `Победа <b>НЕТ</b>: ~${winIfNo.toFixed(2)} T <span class="profit">(+${(winIfNo - amount).toFixed(2)})</span>`;
    }

    function setSending(eventId, isSending, message) {
      const card = document.querySelector(`.card[data-event-id="${eventId}"]`);
      const status = document.getElementById(`status-${eventId}`);
      if (status) status.textContent = message || "";
      if (card) card.querySelectorAll("button").forEach(b => b.disabled = isSending);
    }

    function doBet(eventId, outcome) {
      const info = state.get(eventId);
      if (info?.isResolved) return;

      const amount = parseAmount(document.getElementById(`am-${eventId}`)?.value);
      if (amount === null || amount < MIN_BET) {
        setSending(eventId, false, `Введите сумму (мин. ${MIN_BET.toFixed(2)} TON)`);
        return;
      }

      if (!tg) {
        setSending(eventId, false, "Открой через Telegram");
        return;
      }

      setSending(eventId, true, "Отправляем в бота...");

      try {
        tg.sendData(JSON.stringify({ eventId, outcome, amount: amount.toFixed(2) }));
        setSending(eventId, false, "✅ Отправлено. Заверши оплату в чате с ботом.");
      } catch {
        setSending(eventId, false, "Ошибка отправки в бота");
      }
    }

    function clearTimer() {
      if (refreshTimer) {
        clearInterval(refreshTimer);
        refreshTimer = null;
      }
    }

    function renderApp(root) {
      const note = document.createElement("div");
      note.id = "top-note";
      note.className = "top-note";
      root.appendChild(note);

      root.appendChild(buildFilters(root));

      const ids = [];
      let shown = 0;

      for (const ev of eventList) {
        if (typeof ev?.id !== "number" || !Number.isFinite(ev.id)) continue;
        if (activeCategory !== "all" && String(ev.category || "").toLowerCase() !== activeCategory) continue;

        shown++;
        ids.push(ev.id);
        root.appendChild(buildCard(ev));
      }

      if (shown === 0) {
        const empty = document.createElement("div");
        empty.className = "loading";
        empty.textContent = "В этой категории пока нет событий";
        root.appendChild(empty);
      }

      // ИСПОЛЬЗУЕМ BATCHING: Запрашиваем все ID одним разом
      syncAllEvents(ids);
      clearTimer();
      refreshTimer = setInterval(() => syncAllEvents(ids), REFRESH_MS);
    }

    (function main() {
      const params = new URLSearchParams(window.location.search);
      const b64Data = params.get("data");
      if (!b64Data) {
        setAppError("Нет данных событий (?data=...). Открой WebApp через бота.");
        return;
      }

      try {
        eventList = safeBase64ToJson(b64Data);
        if (!Array.isArray(eventList)) throw new Error("data is not array");
      } catch {
        setAppError("Не удалось прочитать список событий. Открой WebApp заново через бота.");
        return;
      }

      const app = document.getElementById("app");
      app.innerHTML = "";

      if (eventList.length === 0) {
        app.innerHTML = `<div class="loading">Пока нет активных событий</div>`;
        maybeShowUpdateHintOncePerHour();
        return;
      }

      renderApp(app);

      maybeShowUpdateHintOncePerHour();
    })();
  </script>
</body>
</html>
